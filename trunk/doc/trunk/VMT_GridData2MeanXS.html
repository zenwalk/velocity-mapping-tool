<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of VMT_GridData2MeanXS</title>
  <meta name="keywords" content="VMT_GridData2MeanXS">
  <meta name="description" content="This routine generates a uniformly spaced grid for the mean cross section and">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- menu.html trunk -->
<h1>VMT_GridData2MeanXS
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>This routine generates a uniformly spaced grid for the mean cross section and</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [A,V] = VMT_GridData2MeanXS(z,A,V,unitQcorrection) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> This routine generates a uniformly spaced grid for the mean cross section and 
 maps (interpolates) individual transects to this grid.   

 (adapted from code by J. Czuba)

 P.R. Jackson, USGS, 12-9-08
 Last modified: F.L. Engel, USGS 2/20/2013</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="VMT_unitQcont.html" class="code" title="function A = VMT_unitQcont(A,V,z)">VMT_unitQcont</a>	VMT_UNITQCONT applies unit discharge continuity correction MCS velocities</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="VMT_ProcessTransects.html" class="code" title="function [A,V,log_text] = VMT_ProcessTransects(z,A,setends,unitQcorrection)">VMT_ProcessTransects</a>	Driver program to process multiple transects at a single cross-section</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function mypostcallback_zoom(obj,evd)</a></li><li><a href="#_sub2" class="code">function mypostcallback_pan(obj,evd)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [A,V] = VMT_GridData2MeanXS(z,A,V,unitQcorrection)</a>
0002 <span class="comment">% This routine generates a uniformly spaced grid for the mean cross section and</span>
0003 <span class="comment">% maps (interpolates) individual transects to this grid.</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% (adapted from code by J. Czuba)</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% P.R. Jackson, USGS, 12-9-08</span>
0008 <span class="comment">% Last modified: F.L. Engel, USGS 2/20/2013</span>
0009 
0010 <span class="comment">%% User Input</span>
0011 
0012 xgdspc      = A(1).hgns; <span class="comment">%Horizontal Grid node spacing in meters</span>
0013 <span class="comment">%ygdspc      = A(1).vgns; %double(A(1).Sup.binSize_cm)/100; %Vertical Grid node spacing in meters</span>
0014 ygdspc      = double(A(1).Sup.binSize_cm)/100; <span class="comment">%Vertical Grid node spacing in meters</span>
0015 <span class="keyword">if</span> 0
0016     xgdspc  = V.meddens + V.stddens;  <span class="comment">%Auto method should include 67% of the values</span>
0017     <span class="comment">%disp(['X Grid Node Auto Spacing = ' num2str(xgdspc) ' m'])</span>
0018     log_text = [<span class="string">'X Grid Node Auto Spacing = '</span> num2str(xgdspc) <span class="string">' m'</span>];
0019 <span class="keyword">end</span>
0020 
0021 
0022 <span class="comment">%% Determine uniform mean c-s grid for vector interpolating</span>
0023 
0024 <span class="comment">% Determine mean cross-section velocity vector grid</span>
0025 <span class="comment">% NEW: Allowed for explicit specification of vertical grid node spacing</span>
0026 V.mcsDist               = linspace(0,V.dl,floor(V.dl/xgdspc));
0027 V.mcsDepth              = <span class="keyword">...</span>
0028     min(A(1).Wat.binDepth(:)):ygdspc:max(A(1).Wat.binDepth(:));
0029 <span class="comment">% V.mcsDepth              = A(1).Wat.binDepth(:,1);</span>
0030 [V.mcsDist, V.mcsDepth] = meshgrid(V.mcsDist,V.mcsDepth');
0031 
0032 
0033 <span class="comment">% Define the MCS XY points. (REVISED PRJ, 10-18-12)</span>
0034 <span class="comment">% Coordinate assignments depend on the starting</span>
0035 <span class="comment">% point and the slope of the cross section. Theta is limited to 0 to 180</span>
0036 <span class="comment">% (geographic) and 90 to 270 (arithmetic).  For COS, arithmetic angles</span>
0037 <span class="comment">% between 90 and 270 are always negative so no need to add additional IF</span>
0038 <span class="comment">% statement based on the slope.  However, SIN theta (aritmetic) is positive</span>
0039 <span class="comment">% in MFD quadrants 2 and 4 and negative in 1 and 3. Therefore, we use the slope</span>
0040 <span class="comment">% (positive in MFD quadrants 1 and 3, negative in 2 and 4) to determine whether to add or</span>
0041 <span class="comment">% subtract the incremental distances from the start point.  (MFD = mean</span>
0042 <span class="comment">% flow direction, used to define quadrants above and below)</span>
0043 
0044 <span class="keyword">if</span> V.xLeftBank == V.xe <span class="comment">% MFD Quadrants 2 and 3 (east start)</span>
0045     V.mcsX = V.xLeftBank - V.mcsDist(1,:).*cosd(geo2arideg(V.theta));
0046 <span class="keyword">else</span> <span class="comment">% MFD Quadrants 1 and 4 (west start)</span>
0047     V.mcsX = V.xLeftBank + V.mcsDist(1,:).*cosd(geo2arideg(V.theta));
0048 <span class="keyword">end</span>
0049 
0050 <span class="keyword">if</span> V.yLeftBank == V.yn <span class="comment">% MFD Quadrants 1 and 2 (north start)</span>
0051     <span class="keyword">if</span> V.m &gt;= 0 <span class="comment">%MFD Quadrant 2</span>
0052         V.mcsY = V.yLeftBank - V.mcsDist(1,:).*sind(geo2arideg(V.theta)); 
0053     <span class="keyword">else</span> <span class="comment">%MFD Quadrant 1</span>
0054         V.mcsY = V.yLeftBank + V.mcsDist(1,:).*sind(geo2arideg(V.theta));
0055     <span class="keyword">end</span>
0056 <span class="keyword">else</span> <span class="comment">% MFD Quadrants 3 and 4 (south start)</span>
0057     <span class="keyword">if</span> V.m &gt;= 0 <span class="comment">%MFD Quadrant 4</span>
0058         V.mcsY = V.yLeftBank + V.mcsDist(1,:).*sind(geo2arideg(V.theta)); 
0059     <span class="keyword">else</span> <span class="comment">%MFD Quadrant 3</span>
0060         V.mcsY = V.yLeftBank - V.mcsDist(1,:).*sind(geo2arideg(V.theta));
0061     <span class="keyword">end</span>
0062 <span class="keyword">end</span>
0063 
0064 V.mcsX = meshgrid(V.mcsX,V.mcsDepth(:,1));
0065 V.mcsY = meshgrid(V.mcsY,V.mcsDepth(:,1));
0066 
0067 
0068 <span class="comment">% %Plot the MCS on figure 1</span>
0069 <span class="comment">% figure(1); hold on</span>
0070 <span class="comment">% plot(V.xLeftBank,V.yLeftBank,'gs','MarkerFaceColor','g'); hold on  %Green left bank start point</span>
0071 <span class="comment">% plot(V.xRightBank,V.yRightBank,'rs','MarkerFaceColor','r'); hold on %Red right bank end point</span>
0072 <span class="comment">% plot(V.mcsX(1,:),V.mcsY(1,:),'k+'); hold on</span>
0073 <span class="comment">% figure(1); set(gca,'DataAspectRatio',[1 1 1],'PlotBoxAspectRatio',[1 1 1])</span>
0074 <span class="comment">% clear zi</span>
0075 <span class="comment">%</span>
0076 <span class="comment">% % Format the ticks for UTM and allow zooming and panning</span>
0077 <span class="comment">% figure(1);</span>
0078 <span class="comment">% ticks_format('%6.0f','%8.0f'); %formats the ticks for UTM</span>
0079 <span class="comment">% hdlzm_fig1 = zoom;</span>
0080 <span class="comment">% set(hdlzm_fig1,'ActionPostCallback',@mypostcallback_zoom);</span>
0081 <span class="comment">% set(hdlzm_fig1,'Enable','on');</span>
0082 <span class="comment">% hdlpn_fig1 = pan;</span>
0083 <span class="comment">% set(hdlpn_fig1,'ActionPostCallback',@mypostcallback_pan);</span>
0084 <span class="comment">% set(hdlpn_fig1,'Enable','on');</span>
0085 
0086 
0087 <span class="comment">%% If specified, correct the streamwise velocity by enforcing mass</span>
0088 <span class="comment">% flux (capacitor) continuity</span>
0089 <span class="keyword">if</span> unitQcorrection
0090     A = <a href="VMT_unitQcont.html" class="code" title="function A = VMT_unitQcont(A,V,z)">VMT_unitQcont</a>(A,V,z);
0091 <span class="keyword">end</span>
0092 
0093 <span class="comment">%% Interpolate individual transects onto uniform mean c-s grid</span>
0094 <span class="comment">% Fill in uniform grid based on individual transects mapped onto the mean</span>
0095 <span class="comment">% cross-section by interpolating between adjacent points</span>
0096 
0097 <span class="comment">%ZI = interp2(X,Y,Z,XI,YI)</span>
0098 <span class="keyword">for</span> zi = 1 : z
0099  
0100     A(zi).Comp.mcsBack = interp2(A(zi).Comp.itDist, A(zi).Comp.itDepth, <span class="keyword">...</span>
0101         A(zi).Clean.bs(:,A(zi).Comp.vecmap),V.mcsDist, V.mcsDepth);
0102     A(zi).Comp.mcsBack(A(zi).Comp.mcsBack&gt;=255) = NaN;
0103     A(zi).Comp.mcsEast = interp2(A(zi).Comp.itDist, A(zi).Comp.itDepth, <span class="keyword">...</span>
0104         A(zi).Clean.vEast(:,A(zi).Comp.vecmap), V.mcsDist, V.mcsDepth);
0105     A(zi).Comp.mcsNorth = interp2(A(zi).Comp.itDist, A(zi).Comp.itDepth, <span class="keyword">...</span>
0106         A(zi).Clean.vNorth(:,A(zi).Comp.vecmap), V.mcsDist, V.mcsDepth);
0107     A(zi).Comp.mcsVert = interp2(A(zi).Comp.itDist, A(zi).Comp.itDepth, <span class="keyword">...</span>
0108         A(zi).Clean.vVert(:,A(zi).Comp.vecmap), V.mcsDist, V.mcsDepth);
0109     
0110     <span class="comment">%Compute magnitude</span>
0111     A(zi).Comp.mcsMag = sqrt(A(zi).Comp.mcsEast.^2 + A(zi).Comp.mcsNorth.^2);
0112     
0113     
0114     <span class="comment">%For direction, compute from the velocity components</span>
0115     A(zi).Comp.mcsDir = ari2geodeg((atan2(A(zi).Comp.mcsNorth,A(zi).Comp.mcsEast))*180/pi); 
0116     
0117     A(zi).Comp.mcsBed  = interp1(A(zi).Comp.itDist(1,:),<span class="keyword">...</span>
0118         nanmean(A(zi).Nav.depth(A(zi).Comp.vecmap,:),2),V.mcsDist(1,:));
0119     
0120 <span class="keyword">end</span>
0121 
0122 <span class="comment">% clear zi</span>
0123 
0124 <span class="comment">%%%%%%%%%%%%%%%%</span>
0125 <span class="comment">% SUBFUNCTIONS %</span>
0126 <span class="comment">%%%%%%%%%%%%%%%%</span>
0127 <a name="_sub1" href="#_subfunctions" class="code">function mypostcallback_zoom(obj,evd)</a>
0128 ticks_format(<span class="string">'%6.0f'</span>,<span class="string">'%8.0f'</span>); <span class="comment">%formats the ticks for UTM (when zooming)</span>
0129 
0130 <a name="_sub2" href="#_subfunctions" class="code">function mypostcallback_pan(obj,evd)</a>
0131 ticks_format(<span class="string">'%6.0f'</span>,<span class="string">'%8.0f'</span>); <span class="comment">%formats the ticks for UTM (when panning)</span></pre></div>
<hr><address>Generated on Wed 14-Aug-2013 08:31:52 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>