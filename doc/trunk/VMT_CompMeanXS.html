<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of VMT_CompMeanXS</title>
  <meta name="keywords" content="VMT_CompMeanXS">
  <meta name="description" content="Computes the mean cross section data from individual transects">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- menu.html trunk -->
<h1>VMT_CompMeanXS
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>Computes the mean cross section data from individual transects</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [A,V,log_text] = VMT_CompMeanXS(z,A,V) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Computes the mean cross section data from individual transects
 that have been previously mapped to a common grid.

 (adapted from code by J. Czuba)

 P.R. Jackson, USGS, 12-9-08</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="VMT_ProcessTransects.html" class="code" title="function [A,V,log_text] = VMT_ProcessTransects(z,A,setends,unitQcorrection)">VMT_ProcessTransects</a>	Driver program to process multiple transects at a single cross-section</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [A,V,log_text] = VMT_CompMeanXS(z,A,V)</a>
0002 <span class="comment">% Computes the mean cross section data from individual transects</span>
0003 <span class="comment">% that have been previously mapped to a common grid.</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% (adapted from code by J. Czuba)</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% P.R. Jackson, USGS, 12-9-08</span>
0008 
0009 
0010 
0011 <span class="comment">%% Average mapped mean cross-sections from individual transects together</span>
0012 
0013 <span class="comment">% Averaging for backscatter is only computed for Rio Grande probes</span>
0014 <span class="comment">% Procedure for SonTek probes is different</span>
0015 
0016 <span class="keyword">switch</span> V.probeType
0017     <span class="comment">% Assign mapped uniform grid vectors to the same array for averaging</span>
0018     <span class="comment">% Put all of the Sontek data in one place, then interpolate values at</span>
0019     <span class="comment">% the MCS grid</span>
0020     <span class="keyword">case</span> <span class="string">'M9'</span>
0021         
0022         x       = []; 
0023         y       = []; 
0024         East    = [];
0025         North   = [];
0026         Vert    = [];
0027         <span class="keyword">for</span> zi = 1: z
0028             
0029             Dir(:,:,zi) = A(zi).Comp.mcsDir(:,:);
0030             Bed(:,:,zi) = A(zi).Comp.mcsBed(:,:);
0031             
0032             xx    = meshgrid(A(zi).Comp.dl,A(zi).Wat.binDepth(:,1));
0033             x     = [x; xx(:)];
0034             y     = [y; A(zi).Wat.binDepth(:)];
0035             East  = [East;  A(zi).Wat.vEast(:)];
0036             North = [North; A(zi).Wat.vNorth(:)];
0037             Vert  = [Vert;  A(zi).Wat.vVert(:)];
0038         <span class="keyword">end</span>
0039 
0040         <span class="comment">% FIXME: I call griddate 3 times. Need to rewrite to create 1</span>
0041         <span class="comment">% delauney tri, and replace the V data.</span>
0042         V.mcsEast  = griddata(x,y,East,V.mcsDist,V.mcsDepth);
0043         V.mcsNorth = griddata(x,y,North,V.mcsDist,V.mcsDepth);
0044         V.mcsVert  = griddata(x,y,Vert,V.mcsDist,V.mcsDepth);
0045         
0046     <span class="keyword">otherwise</span> <span class="comment">% Could be 'RG' or 'RR'</span>
0047         <span class="keyword">for</span> zi = 1 : z
0048             
0049             Back(:,:,zi) = A(zi).Comp.mcsBack(:,:);
0050             Dir(:,:,zi) = A(zi).Comp.mcsDir(:,:);
0051             Mag(:,:,zi) = A(zi).Comp.mcsMag(:,:);
0052             East(:,:,zi) = A(zi).Comp.mcsEast(:,:);
0053             North(:,:,zi) = A(zi).Comp.mcsNorth(:,:);
0054             Vert(:,:,zi) = A(zi).Comp.mcsVert(:,:);
0055             Bed(:,:,zi) = A(zi).Comp.mcsBed(:,:);
0056             
0057         <span class="keyword">end</span>
0058         
0059         numavg = nansum(~isnan(Mag),3);
0060         numavg(numavg==0) = NaN;
0061         enscnt = nanmean(numavg,1);
0062         [I,J] = ind2sub(size(enscnt),find(enscnt&gt;=1));  <span class="comment">%Changed to &gt;= 1 PRJ 12-10-08  (uses data even if only one measurement)</span>
0063         
0064         
0065         Backone= Back;
0066         Backone(~isnan(Back))=1;
0067         V.countBack = nansum(Backone,3);
0068         V.countBack(V.countBack==0)=NaN;
0069         V.mcsBack = nanmean(Back,3);
0070         
0071         
0072         Magone = Mag;
0073         Vertone = Vert;
0074         Bedone = Bed;
0075         
0076         
0077         Magone(~isnan(Mag))=1;
0078         Vertone(~isnan(Vert))=1;
0079         Bedone(~isnan(Bed))=1;
0080         
0081         
0082         V.countMag = nansum(Magone,3);
0083         V.countVert = nansum(Vertone,3);
0084         V.countBed = nansum(Bedone,3);
0085         
0086         V.countMag(V.countMag==0)=NaN;
0087         V.countVert(V.countVert==0)=NaN;
0088         V.countBed(V.countBed==0)=NaN;
0089         
0090         <span class="comment">% Average mapped mean cross-sections from individual transects together</span>
0091         
0092         <span class="comment">%V.mcsDir = nanmean(Dir,3);  % Will not average correctly in all cases due to 0-360</span>
0093         <span class="comment">%wrapping (PRJ, 9-29-10)</span>
0094         <span class="comment">%V.mcsMag = nanmean(Mag,3);  %Mag recomputed from north, east, up components(PRJ, 3-21-11)</span>
0095         V.mcsEast = nanmean(East,3);
0096         V.mcsNorth = nanmean(North,3);
0097         V.mcsVert = nanmean(Vert,3);
0098     
0099     
0100 
0101 <span class="keyword">end</span> <span class="comment">% switch Probe type</span>
0102 
0103         <span class="comment">%Average Magnitude</span>
0104         V.mcsMag = sqrt(V.mcsEast.^2 + V.mcsNorth.^2 + V.mcsVert.^2);
0105         
0106         <span class="comment">%Average the flow direction</span>
0107         V.mcsDir = ari2geodeg((atan2(V.mcsNorth, V.mcsEast))*180/pi);
0108         <span class="comment">% V.mcsDir = 90 - (atan2(V.mcsNorth, V.mcsEast))*180/pi; %Compute the atan from the velocity componentes, convert to radians, and rotate to north axis</span>
0109         <span class="comment">% qindx = find(V.mcsDir &lt; 0);</span>
0110         <span class="comment">%     if ~isempty(qindx)</span>
0111         <span class="comment">%         V.mcsDir(qindx) = V.mcsDir(qindx) + 360;  %Must add 360 deg to Quadrant 4 values as they are negative angles from the +y axis</span>
0112         <span class="comment">%     end</span>
0113         
0114         V.mcsBed = nanmean(Bed,3);
0115         
0116         <span class="comment">%Compute the Bed Elevation in meters (Takes the mean value of the entered</span>
0117         <span class="comment">%WSE timeseries if file loaded)</span>
0118         <span class="comment">%disp(['Assigned Water Surface Elevation (WSE; in meters) = ' num2str(mean(A(1).wse))])</span>
0119         log_text = [<span class="string">'      WSE in meters) = '</span> num2str(mean(A(1).wse))];
0120         V.mcsBedElev = mean(A(1).wse) - V.mcsBed;
0121         
0122 
0123 
0124 <span class="keyword">return</span>
0125 
0126 <span class="comment">% Remove values (Omitted 11/23/10, PRJ)</span>
0127 <span class="comment">% Clean up</span>
0128 <span class="comment">% switch A(1).probeType</span>
0129 <span class="comment">%     case 'RG'</span>
0130 <span class="comment">%         V.mcsBack(:,1:J(1)-1)=NaN;</span>
0131 <span class="comment">%         V.mcsBack(:,J(end)+1:end)=NaN;</span>
0132 <span class="comment">%         V.countBack(:,1:J(1)-1)=NaN;</span>
0133 <span class="comment">%         V.countBack(:,J(end)+1:end)=NaN;</span>
0134 <span class="comment">% end</span>
0135 <span class="comment">%</span>
0136 <span class="comment">% V.mcsDir(:,1:J(1)-1)=NaN;</span>
0137 <span class="comment">% V.mcsDir(:,J(end)+1:end)=NaN;</span>
0138 <span class="comment">% V.mcsMag(:,1:J(1)-1)=NaN;</span>
0139 <span class="comment">% V.mcsMag(:,J(end)+1:end)=NaN;</span>
0140 <span class="comment">% V.mcsEast(:,1:J(1)-1)=NaN;</span>
0141 <span class="comment">% V.mcsEast(:,J(end)+1:end)=NaN;</span>
0142 <span class="comment">% V.mcsNorth(:,1:J(1)-1)=NaN;</span>
0143 <span class="comment">% V.mcsNorth(:,J(end)+1:end)=NaN;</span>
0144 <span class="comment">% V.mcsVert(:,1:J(1)-1)=NaN;</span>
0145 <span class="comment">% V.mcsVert(:,J(end)+1:end)=NaN;</span>
0146 <span class="comment">% V.mcsBed(:,1:J(1)-1)=NaN;</span>
0147 <span class="comment">% V.mcsBed(:,J(end)+1:end)=NaN;</span>
0148 <span class="comment">% V.countMag(:,1:J(1)-1)=NaN;</span>
0149 <span class="comment">% V.countVert(:,1:J(1)-1)=NaN;</span>
0150 <span class="comment">% V.countBed(:,1:J(1)-1)=NaN;</span>
0151 <span class="comment">% V.countMag(:,J(end)+1:end)=NaN;</span>
0152 <span class="comment">% V.countVert(:,J(end)+1:end)=NaN;</span>
0153 <span class="comment">% V.countBed(:,J(end)+1:end)=NaN;</span>
0154 
0155</pre></div>
<hr><address>Generated on Thu 10-Apr-2014 16:02:29 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>